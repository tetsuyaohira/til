# ソフトウェアアーキテクチャの基礎 - はじめに〜1.1章

## はじめに：公理を疑う

### 核心メッセージ
ソフトウェアの世界は常に変化しているため、過去の「当たり前」（公理）を疑い続けることが重要。

### ソフトウェアエコシステムの特徴
- **動的な平衡状態**：一時的には均衡が保たれているが、長期的には動的に変化する
- 例：Kubernetesは10年前には存在しなかったが、今では専門のカンファレンスが開催されるほど

### アーキテクチャの定義の変化
- **昔**：「後から変更するのが難しいもの」
- **今**：「変化」こそが第一級の設計上の考慮事項（マイクロサービスの登場により）

### 本書のアプローチ
1. **工学的手法**：工芸（職人芸）から工学（再現性・厳密さ）への転換を目指す
2. **トレードオフ分析**：絶対的な正解はない。すべての選択には良い面と悪い面がある
3. **現代的な視点**：過去10年間のイノベーションを考慮した新しい指標や尺度を使用

## 1章　イントロダクション

### ソフトウェアアーキテクトの定義が難しい4つの理由

1. **業界で定義が定まっていない**
   - Martin Fowlerも「アーキテクチャとは（それが何であれ）重要なものだ」としか言っていない

2. **役割が広範囲で拡大し続けている**
   - 10年前：技術的な側面（モジュール性、コンポーネント、パターン）のみ
   - 現在：マイクロサービスなど、より広範囲の能力が必要

3. **ソフトウェア開発エコシステムが急速に進化**
   - 今日の定義も数年後には時代遅れになる可能性
   - Wikipediaの定義も既に時代遅れ

4. **過去の資料が歴史的経緯になっている**
   - 多くの専門用語が役割を終えたものや失敗した試み

### 文脈の重要性
- **2002年の例**：マイクロサービスのようなアーキテクチャは想像できないほど高額
  - 各サービスに専用DBを持たせる = 大量のライセンス料が必要
- **現在**：オープンソースとDevOps革命により、手頃に構築可能
- **教訓**：アーキテクチャの良し悪しは時代や状況によって変わる

## 1.1　ソフトウェアアーキテクチャの定義

### ソフトウェアアーキテクチャ = 4つの要素の組み合わせ

#### 1. 構造（Structure）
- システムを実装するアーキテクチャスタイルの種類
- 例：マイクロサービス、レイヤード、マイクロカーネル
- 注意：構造だけではアーキテクチャの説明にならない

#### 2. アーキテクチャ特性（Architecture Characteristics）
- 「イリティ（-ility）」とも呼ばれる
- システムの成功基準を定めるが、機能とは直接関係しない
- 例：
  - Availability（可用性）
  - Reliability（信頼性）
  - Scalability（スケーラビリティ）

#### 3. アーキテクチャ決定（Architecture Decisions）
- システムをどのように構築すべきかの**ルール**
- 開発チームの制約を形作る
- 例：「プレゼンテーション層は直接データベースにアクセスできない」
- **特例**：どうしても守れない場合は、ARB（アーキテクチャ審査委員会）が審査

#### 4. 設計指針（Design Principles）
- ルールではなく**ガイドライン**
- 開発チームに柔軟性を与える
- 例：「サービス間の通信には非同期メッセージングを使用することを推奨」
- 状況に応じて適切な選択（REST、gRPCなど）が可能

### 重要な区別
- **アーキテクチャ決定** = 絶対的なルール（must）
- **設計指針** = 推奨されるガイドライン（should）

この区別により、統一性を保ちながらも柔軟性のあるシステム開発が可能になる。