---
title: "Clean Architecture 第11章 DIP：依存関係逆転の原則"
date: "2025-01-06"
---

## はじめに

Clean Architectureの第11章では、SOLID原則の最後を飾る「依存関係逆転の原則（Dependency Inversion Principle, DIP）」について解説されている。この原則は、柔軟で保守性の高いシステムを構築する上で極めて重要な役割を果たす。

## DIPとは何か

DIPの本質は「ソースコードの依存関係が（具象ではなく）抽象だけを参照している」ことである。より具体的に言えば、変化しやすい具象実装に依存するのではなく、安定した抽象（インターフェース）に依存すべきという原則だ。

### なぜ「逆転」なのか

従来のプログラミングでは、上位レベルのモジュールが下位レベルのモジュールに依存する構造が一般的だった。DIPはこの依存の方向を「逆転」させる。処理の流れと依存の方向が逆になることから、この名前が付けられている。

## 安定した抽象

抽象インターフェースが具象実装よりも安定している理由は単純だ。インターフェースを変更すると、それに対応する全ての実装を変更する必要がある。一方、実装を変更してもインターフェースの変更は必要ない。優れた設計者は、この特性を活かしてインターフェースの変動性を最小限に抑える。

## DIPの実践的なルール

本書では、DIPを実践するための4つの具体的なルールが示されている：

1. **変化しやすい具象クラスを参照しない**
    - 代わりに抽象インターフェースを参照する
    - オブジェクト生成にはAbstract Factoryパターンを使用

2. **変化しやすい具象クラスを継承しない**
    - 継承は最も強力で厳格な依存関係
    - 特に静的型付け言語では注意が必要

3. **具象関数をオーバーライドしない**
    - 具象関数は他の依存関係を引きずる
    - 代わりに抽象関数を定義し、複数の実装を用意

4. **変化しやすい具象を名指しで参照しない**
    - これはDIPそのものの言い換え

## Abstract Factoryパターン

DIPに従うと、オブジェクト生成時に問題が生じる。`new ConcreteClass()`と書けば、それは具象への依存になってしまう。この問題を解決するのがAbstract Factoryパターンだ。

```java
// インターフェース
interface ServiceFactory {
    Service makeService();
}

// アプリケーションは抽象に依存
class Application {
    private ServiceFactory factory;
    
    public void doSomething() {
        Service service = factory.makeService();
        // serviceを使用
    }
}
```

このパターンにより、アプリケーションは具象クラスを知ることなくオブジェクトを生成できる。

## アーキテクチャの境界

図11-1で示される曲線は、システムを抽象コンポーネントと具象コンポーネントに分割する「アーキテクチャの境界」を表している。全ての依存の矢印はこの境界を越えて抽象側に向かっており、これが「依存性のルール」となる。

## 現実的な妥協

DIPを100%遵守することは現実的ではない。システムには必ず具象への依存が存在する。重要なのは：

- 変化しにくいもの（String、OS機能など）への依存は許容する
- DIP違反を最小限に抑え、特定の場所（mainコンポーネントなど）に隔離する
- ビジネスロジックは抽象に依存させる

## 現代的な実践

2000年代のオブジェクト指向全盛期には、深い継承階層が一般的だった。しかし現在では：

- 継承より委譲（Composition over Inheritance）が推奨される
- DIコンテナによる依存性注入が主流
- インターフェースと委譲を組み合わせた設計が好まれる

## まとめ

DIPは単なる設計原則ではなく、アーキテクチャ全体を考える基礎となる。本書の後半でも、この原則は「アーキテクチャの境界」や「依存性のルール」として繰り返し登場する。完璧を求めるのではなく、現実的な妥協点を見つけながら、変化に強い柔軟なシステムを構築することが重要である。